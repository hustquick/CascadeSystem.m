
<!DOCTYPE html
  PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head>
      <meta http-equiv="Content-Type" content="text/html; charset=utf-8">
   <!--
This HTML was auto-generated from MATLAB code.
To make changes, update the MATLAB code and republish this document.
      --><title>main</title><meta name="generator" content="MATLAB 8.4"><link rel="schema.DC" href="http://purl.org/dc/elements/1.1/"><meta name="DC.date" content="2016-03-21"><meta name="DC.source" content="main.m"><style type="text/css">
html,body,div,span,applet,object,iframe,h1,h2,h3,h4,h5,h6,p,blockquote,pre,a,abbr,acronym,address,big,cite,code,del,dfn,em,font,img,ins,kbd,q,s,samp,small,strike,strong,sub,sup,tt,var,b,u,i,center,dl,dt,dd,ol,ul,li,fieldset,form,label,legend,table,caption,tbody,tfoot,thead,tr,th,td{margin:0;padding:0;border:0;outline:0;font-size:100%;vertical-align:baseline;background:transparent}body{line-height:1}ol,ul{list-style:none}blockquote,q{quotes:none}blockquote:before,blockquote:after,q:before,q:after{content:'';content:none}:focus{outine:0}ins{text-decoration:none}del{text-decoration:line-through}table{border-collapse:collapse;border-spacing:0}

html { min-height:100%; margin-bottom:1px; }
html body { height:100%; margin:0px; font-family:Arial, Helvetica, sans-serif; font-size:10px; color:#000; line-height:140%; background:#fff none; overflow-y:scroll; }
html body td { vertical-align:top; text-align:left; }

h1 { padding:0px; margin:0px 0px 25px; font-family:Arial, Helvetica, sans-serif; font-size:1.5em; color:#d55000; line-height:100%; font-weight:normal; }
h2 { padding:0px; margin:0px 0px 8px; font-family:Arial, Helvetica, sans-serif; font-size:1.2em; color:#000; font-weight:bold; line-height:140%; border-bottom:1px solid #d6d4d4; display:block; }
h3 { padding:0px; margin:0px 0px 5px; font-family:Arial, Helvetica, sans-serif; font-size:1.1em; color:#000; font-weight:bold; line-height:140%; }

a { color:#005fce; text-decoration:none; }
a:hover { color:#005fce; text-decoration:underline; }
a:visited { color:#004aa0; text-decoration:none; }

p { padding:0px; margin:0px 0px 20px; }
img { padding:0px; margin:0px 0px 20px; border:none; }
p img, pre img, tt img, li img, h1 img, h2 img { margin-bottom:0px; } 

ul { padding:0px; margin:0px 0px 20px 23px; list-style:square; }
ul li { padding:0px; margin:0px 0px 7px 0px; }
ul li ul { padding:5px 0px 0px; margin:0px 0px 7px 23px; }
ul li ol li { list-style:decimal; }
ol { padding:0px; margin:0px 0px 20px 0px; list-style:decimal; }
ol li { padding:0px; margin:0px 0px 7px 23px; list-style-type:decimal; }
ol li ol { padding:5px 0px 0px; margin:0px 0px 7px 0px; }
ol li ol li { list-style-type:lower-alpha; }
ol li ul { padding-top:7px; }
ol li ul li { list-style:square; }

.content { font-size:1.2em; line-height:140%; padding: 20px; }

pre, code { font-size:12px; }
tt { font-size: 1.2em; }
pre { margin:0px 0px 20px; }
pre.codeinput { padding:10px; border:1px solid #d3d3d3; background:#f7f7f7; }
pre.codeoutput { padding:10px 11px; margin:0px 0px 20px; color:#4c4c4c; }
pre.error { color:red; }

@media print { pre.codeinput, pre.codeoutput { word-wrap:break-word; width:100%; } }

span.keyword { color:#0000FF }
span.comment { color:#228B22 }
span.string { color:#A020F0 }
span.untermstring { color:#B20000 }
span.syscmd { color:#B28C00 }

.footer { width:auto; padding:10px 0px; margin:25px 0px 0px; border-top:1px dotted #878787; font-size:0.8em; line-height:140%; font-style:italic; color:#878787; text-align:left; float:none; }
.footer p { margin:0px; }
.footer a { color:#878787; }
.footer a:hover { color:#878787; text-decoration:underline; }
.footer a:visited { color:#878787; }

table th { padding:7px 5px; text-align:left; vertical-align:middle; border: 1px solid #d6d4d4; font-weight:bold; }
table td { padding:7px 5px; text-align:left; vertical-align:top; border:1px solid #d6d4d4; }





  </style></head><body><div class="content"><h2>Contents</h2><div><ul><li><a href="#2">Dish Collector Part</a></li><li><a href="#3">Stirling Engine Array</a></li><li><a href="#4">Trough Collector</a></li><li><a href="#5">Turbine</a></li></ul></div><pre class="codeinput">clear;
</pre><h2>Dish Collector Part<a name="2"></a></h2><p>A dish collector is built under given ambient parameters</p><pre class="codeinput">amb = Ambient;

st1(3) = Stream;

st1(1).fluid = char(Const.Fluid(1));
st1(1).T = Temperature(C2K(800));
st1(1).p = 5e5;

ap = AirPipe;
il = InsLayer;

st_dc_i = Stream;
    st_dc_i.fluid = char(Const.Fluid(1));
    st_dc_i.T = Temperature(C2K(350));
    st_dc_i.p = 5e5;

st_dc_o = st_dc_i.flow();
    st_dc_o.T = Temperature(C2K(800));
    st_dc_o.p = st_dc_i.p;

dc = DishCollector;
    dc.amb = amb;
    dc.st_i = st_dc_i;
    dc.st_o = st_dc_o;
    dc.airPipe = ap;
    dc.insLayer = il;

    guess1 = [1500; 400; 0.1] ;
    options = optimset(<span class="string">'Display'</span>,<span class="string">'iter'</span>);
    [x1, fval1] = fsolve(@(x1)CalcDishCollector(x1, dc), <span class="keyword">...</span>
        guess1, options);
dc
</pre><pre class="codeoutput">
                                         Norm of      First-order   Trust-region
 Iteration  Func-count     f(x)          step         optimality    radius
     0          4     4.92364e+08                      5.74e+09               1
     1          8     3.47306e+08              1       5.11e+08               1
     2         12     3.38708e+08            2.5       9.53e+06             2.5
     3         16     3.20205e+08           6.25       1.12e+08            6.25
     4         20     2.75108e+08         15.625        2.7e+08            15.6
     5         24     1.72295e+08        39.0625       5.22e+08            39.1
     6         28     1.26527e+07        97.6562       2.89e+08            97.7
     7         32         5234.88        38.1153       1.54e+07             244
     8         36      0.00188801       0.785437       6.96e+03             244
     9         40     1.70391e-16    0.000486987        0.00233             244
    10         44     5.29476e-22    1.61689e-10       5.81e-06             244

Equation solved, fsolve stalled.

fsolve stopped because the relative size of the current step is less than the
default value of the step size tolerance squared and the vector of function values
is near zero as measured by the default value of the function tolerance.




dc = 

  DishCollector with properties:

           A: 87.7000
       gamma: 0.9700
         rho: 0.9100
     shading: 0.9500
        d_ap: 0.1840
       d_cav: 0.4600
     dep_cav: 0.2300
       theta: 0.7854
         amb: [1x1 Ambient]
         T_p: [1x1 Temperature]
       T_ins: [1x1 Temperature]
        st_i: [1x1 Stream]
        st_o: [1x1 Stream]
     airPipe: [1x1 AirPipe]
    insLayer: [1x1 InsLayer]
       q_use: 4.4368e+04
       q_tot: 61390
         eta: 0.7227

</pre><h2>Stirling Engine Array<a name="3"></a></h2><p>Two kinds of connection orders of the Stirling engines are considered.</p><pre class="codeinput">order = <span class="string">'Reverse'</span>; <span class="comment">% can be 'Same', 'Reverse' and other types, n_1! types all together</span>
n1 = 10;                <span class="comment">% Column number of Stirling engine array</span>
n2 = Const.NUM_SE / n1; <span class="comment">% Row number of Stirling engine array</span>
guess2 = zeros(2,n1);   <span class="comment">% 2 * n1 unknown parameters (outlet temperature of two fluids in each column)</span>

q_m_1 = 2.990;  <span class="comment">% To be calculated!</span>
q_m_2 = 5.625;  <span class="comment">% To be calculated;</span>

<span class="comment">% st1_se_i = dc.st_o;            % Not right for the q_m, so next line corrects the q_m</span>
st1_se_i = Stream;              <span class="comment">% to be changed!!!!!</span>
    st1_se_i.fluid = char(Const.Fluid(2));
    st1_se_i.T.v = dc.st_o.T.v;
    st1_se_i.p = dc.st_o.p;
    st1_se_i.q_m.v = q_m_1 / n2;
se_cp_1 = CoolProp.PropsSI(<span class="string">'C'</span>, <span class="string">'T'</span>, st1_se_i.T.v, <span class="string">'P'</span>, <span class="keyword">...</span>
    st1_se_i.p, st1_se_i.fluid);

st2_se_i = Stream;
    st2_se_i.fluid = char(Const.Fluid(2));
    st2_se_i.T = Temperature(327.2);
    st2_se_i.p = 1e6;
        st2_se_i.q_m.v = q_m_2 / n2;
se_cp_2 = CoolProp.PropsSI(<span class="string">'C'</span>, <span class="string">'T'</span>, st2_se_i.T.v, <span class="string">'P'</span>, <span class="keyword">...</span>
        st2_se_i.p, st2_se_i.fluid);

se(1,n1) = StirlingEngine;

se(1) = StirlingEngine;
se(1).flowType = order; <span class="comment">% can be changed</span>
se(1).st1_i = st1_se_i;
se(1).st1_o = se(1).st1_i.flow();
    se(1).st1_o.p = se(1).st1_i.p;
se(1).cp_1 = se_cp_1;

<span class="keyword">if</span> (strcmp(order, <span class="string">'Same'</span>))
    <span class="comment">%%%%% Same order %%%%%</span>
    se(1).st2_i = st2_se_i;
    se(1).st2_o = Stream.flow(se(1).st2_i);
        se(1).st2_o.p = se(1).st2_i.p;
    se(1).cp_2 = se_cp_2;
    <span class="keyword">for</span> i = 2:n1
        se(i) = StirlingEngine;
            se(i).flowType = se(1).flowType;    <span class="comment">% Flowtype of any Stirling engine can be changed seperately</span>
            se(i).cp_1 = se_cp_1;
            se(i).cp_2 = se_cp_2;
        se(i).st1_i = se(i-1).st1_o;
        se(i).st2_i = se(i-1).st2_o;
        se(i).st1_o = Stream.flow(se(i).st1_i);
            se(i).st1_o.p = se(i).st1_i.p;
        se(i).st2_o = Stream.flow(se(i).st2_i);
            se(i).st2_o.p = se(i).st2_i.p;
    <span class="keyword">end</span>

    <span class="keyword">for</span> j = 1:n1
        guess2(j,1) = se(1).st1_i.T.v - 40 * j;
        guess2(j,2) = se(1).st2_i.T.v + 4 * j;
    <span class="keyword">end</span>
<span class="keyword">elseif</span> (strcmp(order,<span class="string">'Reverse'</span>))
    <span class="comment">%%%%% Inverse order %%%%%</span>
    se(1).cp_2 = se_cp_2;
    <span class="keyword">for</span> i = 2:n1
        se(i) = StirlingEngine;
            se(i).flowType = se(1).flowType; <span class="comment">% Flowtype of any Stirling engine can be changed seperately</span>
            se(i).cp_1 = se_cp_1;
            se(i).cp_2 = se_cp_2;
    <span class="keyword">end</span>
    se(n1).st2_i = st2_se_i;
    se(n1).st2_o = se(n1).st2_i.flow();
        se(n1).st2_o.p = se(n1).st2_i.p;

    <span class="keyword">for</span> i = 1:n1-1
        se(i+1).st1_i = se(i).st1_o;
        se(n1-i).st2_i = se(n1+1-i).st2_o;

        se(i+1).st1_o = se(i+1).st1_i.flow();
            se(i+1).st1_o.p = se(i+1).st1_i.p;
        se(n1-i).st2_o = se(n1-i).st2_i.flow();
            se(n1-i).st2_o.p = se(n1-i).st2_i.p;
    <span class="keyword">end</span>

    <span class="keyword">for</span> j = 1:n1
        guess2(j,1) = se(1).st1_i.T.v - 30 * j;
        guess2(j,2) = se(n1).st2_i.T.v + 4 * (n1 + 1 - j);
    <span class="keyword">end</span>
<span class="keyword">else</span>
    error(<span class="string">'Uncomplished work.'</span>);
<span class="keyword">end</span>

[x2, fval2] = fsolve(@(x2)CalcSEA(x2, se), guess2, options);
<span class="comment">%%%%%%%%%%%%%%%%%% For comparison!!  %%%%%%%%%%%%%%%%%</span>
<span class="comment">%</span>
<span class="comment">% if (strcmp(order, 'Same'))</span>
<span class="comment">%     eta_ses1 = 1 - (st2_se_i.q_m.v * se_cp_2 * (se(n1).st2_o.T.v - ...</span>
<span class="comment">%         se(1).st2_i.T.v)) / (st1_se_i.q_m.v * se_cp_1 * ...</span>
<span class="comment">%         (se(1).st1_i.T.v - se(n1).st1_o.T.v));</span>
<span class="comment">% elseif (strcmp(order,'Reverse'))</span>
<span class="comment">%     eta_ses1 = 1 - (st2_se_i.q_m.v * se_cp_2 * (se(1).st2_o.T.v - ...</span>
<span class="comment">%         se(n1).st2_i.T.v)) / (st1_se_i.q_m.v * se_cp_1 * ...</span>
<span class="comment">%         (se(1).st1_i.T.v - se(n1).st1_o.T.v));</span>
<span class="comment">% else</span>
<span class="comment">%     error('Uncomplished work.');</span>
<span class="comment">% end</span>

P = zeros(n1,1);

<span class="keyword">for</span> i = 1:n1
    se(i).st1_o.T.v = x2(i, 1);
    se(i).st2_o.T.v = x2(i, 2);
    se(i).P = se(i).P1();
    P(i) = se(i).P2();
<span class="keyword">end</span>
eta_ses = sum(P) ./ (st1_se_i.q_m.v * se_cp_1 * <span class="keyword">...</span>
    (se(1).st1_i.T.v - se(n1).st1_o.T.v));
P
eta_ses
</pre><pre class="codeoutput">Warning: Trust-region-dogleg algorithm of FSOLVE cannot handle non-square
systems; using Levenberg-Marquardt algorithm instead. 

                                        First-Order                    Norm of 
 Iteration  Func-count    Residual       optimality      Lambda           step
     0         101         55.1923            1.04         0.01
     1         202         7.23262           0.408        0.001        33.7703
     2         303         2.37794           0.572       0.0001        21.9072
     3         404        0.904698          0.0442        1e-05        64.5714
     4         505       0.0371071          0.0228        1e-06        115.264
     5         606     4.25097e-05         0.00134        1e-07        24.6898
     6         707     1.28062e-10        2.14e-07        1e-08       0.546059
     7         808     6.37095e-18        1.55e-10        1e-09      0.0016382

Equation solved, fsolve stalled.

fsolve stopped because the relative size of the current step is less than the
default value of the step size tolerance and the vector of function values
is near zero as measured by the default value of the function tolerance.




P =

   1.0e+03 *

    5.0585
    4.9410
    4.8259
    4.7132
    4.6030
    4.4951
    4.3895
    4.2861
    4.1850
    4.0860


eta_ses =

    0.3538

</pre><h2>Trough Collector<a name="4"></a></h2><pre class="codeinput">amb = Ambient;
tc = TroughCollector;
    tc.amb = amb;

st3(4) = Stream;

st3(1).fluid = char(Const.Fluid(3));
st3(1).T = Temperature(C2K(400));
st3(1).p = 2e6;
st3(1).q_m.v = 53.41;  <span class="comment">% To be calculated</span>

st3_tc_o = Stream;
st3_tc_o.fluid = char(Const.Fluid(3));
st3_tc_o.T = Temperature(C2K(350));
st3_tc_o.p = 2e6;
st3_tc_o.q_m.v = 3.41;  <span class="comment">% To be calculated</span>

st3_tc_i = st3_tc_o.flow();
    st3_tc_i.T = Temperature(C2K(225));
    st3_tc_i.p = st3_tc_o.p;

tc.st_i = st3_tc_i;
tc.st_o = st3_tc_o;

da = Deaerator;
da.p = 1e6;

st2(11) = Stream;

st2(1).fluid = char(Const.Fluid(2));
st2(1).T = Temperature(C2K(340));
st2(1).p = 2.35e6;
st2(1).q_m.v = 6.672;  <span class="comment">% To be calculated</span>

st2(2).fluid = st2(1).fluid;
st2(2).p = 1.5e4;

st2(3).fluid = st2(1).fluid;
<span class="comment">% st2(3).p = da.p;</span>
st2(3).p = 1e6;
tc
</pre><pre class="codeoutput">
tc = 

  TroughCollector with properties:

          A: 545
      gamma: 0.9300
        rho: 0.9400
    shading: 1
        tau: 0.9500
      alpha: 0.9600
          w: 5.7600
         Fe: 0.9700
        d_i: 0.0660
        d_o: 0.0700
        phi: 1.2217
        amb: [1x1 Ambient]
       st_i: [1x1 Stream]
       st_o: [1x1 Stream]
      q_use: 2.7649e+05
      q_tot: 381500
        eta: 0.7247

</pre><h2>Turbine<a name="5"></a></h2><p>A steam turbine is created</p><pre class="codeinput">tb = Turbine;
    tb.st1 = st2(1);
    tb.st2 = st2(2);
    tb.st3 = st2(3);
    tb.y = 0.1;
tb.calculate();
tb
</pre><pre class="codeoutput">
tb = 

  Turbine with properties:

      st1: [1x1 Stream]
      st2: [1x1 Stream]
      st3: [1x1 Stream]
        y: 0.1000
    eta_i: 0.7841

</pre><p class="footer"><br><a href="http://www.mathworks.com/products/matlab/">Published with MATLAB&reg; R2014b</a><br></p></div><!--
##### SOURCE BEGIN #####
clear;

%% Dish Collector Part
% A dish collector is built under given ambient parameters

amb = Ambient;

st1(3) = Stream;

st1(1).fluid = char(Const.Fluid(1));
st1(1).T = Temperature(C2K(800));
st1(1).p = 5e5;
    
ap = AirPipe;
il = InsLayer;

st_dc_i = Stream;
    st_dc_i.fluid = char(Const.Fluid(1));
    st_dc_i.T = Temperature(C2K(350));
    st_dc_i.p = 5e5;

st_dc_o = st_dc_i.flow();
    st_dc_o.T = Temperature(C2K(800));
    st_dc_o.p = st_dc_i.p;
    
dc = DishCollector;
    dc.amb = amb;
    dc.st_i = st_dc_i;
    dc.st_o = st_dc_o;
    dc.airPipe = ap;
    dc.insLayer = il;

    guess1 = [1500; 400; 0.1] ;
    options = optimset('Display','iter');
    [x1, fval1] = fsolve(@(x1)CalcDishCollector(x1, dc), ...
        guess1, options);
dc
%% Stirling Engine Array
% Two kinds of connection orders of the Stirling engines are considered.

order = 'Reverse'; % can be 'Same', 'Reverse' and other types, n_1! types all together
n1 = 10;                % Column number of Stirling engine array
n2 = Const.NUM_SE / n1; % Row number of Stirling engine array
guess2 = zeros(2,n1);   % 2 * n1 unknown parameters (outlet temperature of two fluids in each column)

q_m_1 = 2.990;  % To be calculated!
q_m_2 = 5.625;  % To be calculated;

% st1_se_i = dc.st_o;            % Not right for the q_m, so next line corrects the q_m
st1_se_i = Stream;              % to be changed!!!!!
    st1_se_i.fluid = char(Const.Fluid(2));
    st1_se_i.T.v = dc.st_o.T.v;
    st1_se_i.p = dc.st_o.p;
    st1_se_i.q_m.v = q_m_1 / n2;      
se_cp_1 = CoolProp.PropsSI('C', 'T', st1_se_i.T.v, 'P', ...
    st1_se_i.p, st1_se_i.fluid);
    
st2_se_i = Stream;
    st2_se_i.fluid = char(Const.Fluid(2));
    st2_se_i.T = Temperature(327.2);
    st2_se_i.p = 1e6;
        st2_se_i.q_m.v = q_m_2 / n2;
se_cp_2 = CoolProp.PropsSI('C', 'T', st2_se_i.T.v, 'P', ...
        st2_se_i.p, st2_se_i.fluid);

se(1,n1) = StirlingEngine;

se(1) = StirlingEngine;
se(1).flowType = order; % can be changed
se(1).st1_i = st1_se_i;
se(1).st1_o = se(1).st1_i.flow();
    se(1).st1_o.p = se(1).st1_i.p;
se(1).cp_1 = se_cp_1;

if (strcmp(order, 'Same'))
    %%%%% Same order %%%%%
    se(1).st2_i = st2_se_i;
    se(1).st2_o = Stream.flow(se(1).st2_i);
        se(1).st2_o.p = se(1).st2_i.p;    
    se(1).cp_2 = se_cp_2;
    for i = 2:n1
        se(i) = StirlingEngine;
            se(i).flowType = se(1).flowType;    % Flowtype of any Stirling engine can be changed seperately
            se(i).cp_1 = se_cp_1;
            se(i).cp_2 = se_cp_2;
        se(i).st1_i = se(i-1).st1_o;
        se(i).st2_i = se(i-1).st2_o;
        se(i).st1_o = Stream.flow(se(i).st1_i);
            se(i).st1_o.p = se(i).st1_i.p;
        se(i).st2_o = Stream.flow(se(i).st2_i);
            se(i).st2_o.p = se(i).st2_i.p;
    end

    for j = 1:n1
        guess2(j,1) = se(1).st1_i.T.v - 40 * j;
        guess2(j,2) = se(1).st2_i.T.v + 4 * j;
    end
elseif (strcmp(order,'Reverse'))
    %%%%% Inverse order %%%%%
    se(1).cp_2 = se_cp_2;
    for i = 2:n1
        se(i) = StirlingEngine;
            se(i).flowType = se(1).flowType; % Flowtype of any Stirling engine can be changed seperately
            se(i).cp_1 = se_cp_1;
            se(i).cp_2 = se_cp_2;
    end
    se(n1).st2_i = st2_se_i;
    se(n1).st2_o = se(n1).st2_i.flow();
        se(n1).st2_o.p = se(n1).st2_i.p;    
    
    for i = 1:n1-1
        se(i+1).st1_i = se(i).st1_o;
        se(n1-i).st2_i = se(n1+1-i).st2_o;

        se(i+1).st1_o = se(i+1).st1_i.flow();
            se(i+1).st1_o.p = se(i+1).st1_i.p;
        se(n1-i).st2_o = se(n1-i).st2_i.flow();
            se(n1-i).st2_o.p = se(n1-i).st2_i.p;
    end
    
    for j = 1:n1
        guess2(j,1) = se(1).st1_i.T.v - 30 * j;
        guess2(j,2) = se(n1).st2_i.T.v + 4 * (n1 + 1 - j);
    end
else
    error('Uncomplished work.');
end

[x2, fval2] = fsolve(@(x2)CalcSEA(x2, se), guess2, options);
%%%%%%%%%%%%%%%%%% For comparison!!  %%%%%%%%%%%%%%%%%
%
% if (strcmp(order, 'Same'))
%     eta_ses1 = 1 - (st2_se_i.q_m.v * se_cp_2 * (se(n1).st2_o.T.v - ...
%         se(1).st2_i.T.v)) / (st1_se_i.q_m.v * se_cp_1 * ...
%         (se(1).st1_i.T.v - se(n1).st1_o.T.v)); 
% elseif (strcmp(order,'Reverse'))
%     eta_ses1 = 1 - (st2_se_i.q_m.v * se_cp_2 * (se(1).st2_o.T.v - ...
%         se(n1).st2_i.T.v)) / (st1_se_i.q_m.v * se_cp_1 * ...
%         (se(1).st1_i.T.v - se(n1).st1_o.T.v)); 
% else
%     error('Uncomplished work.');
% end

P = zeros(n1,1);

for i = 1:n1
    se(i).st1_o.T.v = x2(i, 1);
    se(i).st2_o.T.v = x2(i, 2);
    se(i).P = se(i).P1();
    P(i) = se(i).P2();
end
eta_ses = sum(P) ./ (st1_se_i.q_m.v * se_cp_1 * ...
    (se(1).st1_i.T.v - se(n1).st1_o.T.v)); 
P
eta_ses
%% Trough Collector
% 

amb = Ambient;
tc = TroughCollector;
    tc.amb = amb;

st3(4) = Stream;

st3(1).fluid = char(Const.Fluid(3));
st3(1).T = Temperature(C2K(400));
st3(1).p = 2e6;
st3(1).q_m.v = 53.41;  % To be calculated

st3_tc_o = Stream;
st3_tc_o.fluid = char(Const.Fluid(3));
st3_tc_o.T = Temperature(C2K(350));
st3_tc_o.p = 2e6;
st3_tc_o.q_m.v = 3.41;  % To be calculated

st3_tc_i = st3_tc_o.flow();
    st3_tc_i.T = Temperature(C2K(225));
    st3_tc_i.p = st3_tc_o.p;

tc.st_i = st3_tc_i;
tc.st_o = st3_tc_o;

da = Deaerator;
da.p = 1e6;

st2(11) = Stream;

st2(1).fluid = char(Const.Fluid(2));
st2(1).T = Temperature(C2K(340));
st2(1).p = 2.35e6;
st2(1).q_m.v = 6.672;  % To be calculated

st2(2).fluid = st2(1).fluid;
st2(2).p = 1.5e4;

st2(3).fluid = st2(1).fluid;
% st2(3).p = da.p;
st2(3).p = 1e6;
tc
%% Turbine
% A steam turbine is created 
tb = Turbine;
    tb.st1 = st2(1);
    tb.st2 = st2(2);
    tb.st3 = st2(3);
    tb.y = 0.1;
tb.calculate();
tb
%%

    
##### SOURCE END #####
--></body></html>