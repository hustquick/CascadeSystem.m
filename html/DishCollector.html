
<!DOCTYPE html
  PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head>
      <meta http-equiv="Content-Type" content="text/html; charset=utf-8">
   <!--
This HTML was auto-generated from MATLAB code.
To make changes, update the MATLAB code and republish this document.
      --><title>DishCollector</title><meta name="generator" content="MATLAB 8.4"><link rel="schema.DC" href="http://purl.org/dc/elements/1.1/"><meta name="DC.date" content="2016-03-21"><meta name="DC.source" content="DishCollector.m"><style type="text/css">
html,body,div,span,applet,object,iframe,h1,h2,h3,h4,h5,h6,p,blockquote,pre,a,abbr,acronym,address,big,cite,code,del,dfn,em,font,img,ins,kbd,q,s,samp,small,strike,strong,sub,sup,tt,var,b,u,i,center,dl,dt,dd,ol,ul,li,fieldset,form,label,legend,table,caption,tbody,tfoot,thead,tr,th,td{margin:0;padding:0;border:0;outline:0;font-size:100%;vertical-align:baseline;background:transparent}body{line-height:1}ol,ul{list-style:none}blockquote,q{quotes:none}blockquote:before,blockquote:after,q:before,q:after{content:'';content:none}:focus{outine:0}ins{text-decoration:none}del{text-decoration:line-through}table{border-collapse:collapse;border-spacing:0}

html { min-height:100%; margin-bottom:1px; }
html body { height:100%; margin:0px; font-family:Arial, Helvetica, sans-serif; font-size:10px; color:#000; line-height:140%; background:#fff none; overflow-y:scroll; }
html body td { vertical-align:top; text-align:left; }

h1 { padding:0px; margin:0px 0px 25px; font-family:Arial, Helvetica, sans-serif; font-size:1.5em; color:#d55000; line-height:100%; font-weight:normal; }
h2 { padding:0px; margin:0px 0px 8px; font-family:Arial, Helvetica, sans-serif; font-size:1.2em; color:#000; font-weight:bold; line-height:140%; border-bottom:1px solid #d6d4d4; display:block; }
h3 { padding:0px; margin:0px 0px 5px; font-family:Arial, Helvetica, sans-serif; font-size:1.1em; color:#000; font-weight:bold; line-height:140%; }

a { color:#005fce; text-decoration:none; }
a:hover { color:#005fce; text-decoration:underline; }
a:visited { color:#004aa0; text-decoration:none; }

p { padding:0px; margin:0px 0px 20px; }
img { padding:0px; margin:0px 0px 20px; border:none; }
p img, pre img, tt img, li img, h1 img, h2 img { margin-bottom:0px; } 

ul { padding:0px; margin:0px 0px 20px 23px; list-style:square; }
ul li { padding:0px; margin:0px 0px 7px 0px; }
ul li ul { padding:5px 0px 0px; margin:0px 0px 7px 23px; }
ul li ol li { list-style:decimal; }
ol { padding:0px; margin:0px 0px 20px 0px; list-style:decimal; }
ol li { padding:0px; margin:0px 0px 7px 23px; list-style-type:decimal; }
ol li ol { padding:5px 0px 0px; margin:0px 0px 7px 0px; }
ol li ol li { list-style-type:lower-alpha; }
ol li ul { padding-top:7px; }
ol li ul li { list-style:square; }

.content { font-size:1.2em; line-height:140%; padding: 20px; }

pre, code { font-size:12px; }
tt { font-size: 1.2em; }
pre { margin:0px 0px 20px; }
pre.codeinput { padding:10px; border:1px solid #d3d3d3; background:#f7f7f7; }
pre.codeoutput { padding:10px 11px; margin:0px 0px 20px; color:#4c4c4c; }
pre.error { color:red; }

@media print { pre.codeinput, pre.codeoutput { word-wrap:break-word; width:100%; } }

span.keyword { color:#0000FF }
span.comment { color:#228B22 }
span.string { color:#A020F0 }
span.untermstring { color:#B20000 }
span.syscmd { color:#B28C00 }

.footer { width:auto; padding:10px 0px; margin:25px 0px 0px; border-top:1px dotted #878787; font-size:0.8em; line-height:140%; font-style:italic; color:#878787; text-align:left; float:none; }
.footer p { margin:0px; }
.footer a { color:#878787; }
.footer a:hover { color:#878787; text-decoration:underline; }
.footer a:visited { color:#878787; }

table th { padding:7px 5px; text-align:left; vertical-align:middle; border: 1px solid #d6d4d4; font-weight:bold; }
table td { padding:7px 5px; text-align:left; vertical-align:top; border:1px solid #d6d4d4; }





  </style></head><body><div class="content"><pre class="codeinput"><span class="keyword">classdef</span> DishCollector
    <span class="comment">%DishCollector is a kind of Collector who uses dish as the reflector</span>
    <span class="comment">%and uses volumetric receiver</span>

    <span class="keyword">properties</span>(Constant)
        A = 87.7;         <span class="comment">% Aperture area of the collector, m^2</span>
        gamma = 0.97;       <span class="comment">% Intercept factor of the collector</span>
        rho = 0.91;         <span class="comment">% Reflectance of the collector</span>
        shading = 0.95;     <span class="comment">% Shading factor of the collector</span>
        d_ap = 0.184;       <span class="comment">% Aperture diameter of the dish receiver, m</span>
        d_cav = 0.46;       <span class="comment">% Diameter of the cavity of the dish receiver, m</span>
        dep_cav = 0.23;     <span class="comment">% Depth of the cavity of the dish receiver, m</span>
        theta = Deg2Rad(45);<span class="comment">% Dish aperture angle(0 is horizontal, 90 is vertically down)</span>
    <span class="keyword">end</span>
    <span class="keyword">properties</span>
        amb;        <span class="comment">% Ambient</span>
        T_p;        <span class="comment">% Temperature of the fluid pipe, K</span>
        T_ins;      <span class="comment">% Outside temperature of the insulating layer, K</span>
        st_i;       <span class="comment">% Inlet stream</span>
        st_o;       <span class="comment">% Outlet stream</span>
        airPipe;    <span class="comment">% Air pipe</span>
        insLayer;   <span class="comment">% Insulating layer</span>
    <span class="keyword">end</span>
    <span class="keyword">properties</span>(Dependent)
        q_use;      <span class="comment">% Energy used, transferred to the fluid</span>
        q_tot;      <span class="comment">% Energy projected to the reflector, W</span>
        eta;        <span class="comment">% Thermal efficiency of the collector</span>
    <span class="keyword">end</span>
    <span class="keyword">properties</span>(Dependent, Access = protected)
        A_ins;      <span class="comment">% Insulating layer outside area, m^2</span>
        A_cav;      <span class="comment">% Cavity area, m^2</span>
    <span class="keyword">end</span>

    <span class="keyword">methods</span>
        <span class="keyword">function</span> obj = DishCollector
            obj.amb = Ambient;
            obj.T_ins = Temperature;
            obj.T_p = Temperature;
            obj.airPipe = AirPipe;
            obj.insLayer = InsLayer;
            obj.st_i = Stream;
            obj.st_o = Stream;
        <span class="keyword">end</span>
        <span class="keyword">function</span> q_in = q_in(obj)
            <span class="comment">% The accepted energy from the reflector, W</span>
            q_in = obj.amb.I_r .* obj.A .* obj.gamma * obj.shading * obj.rho;
        <span class="keyword">end</span>
        <span class="keyword">function</span> q_dr_1 = q_dr_1_1(obj)
            <span class="comment">% Heat absorbed by the fluid, W</span>
            h_o = CoolProp.PropsSI(<span class="string">'H'</span>, <span class="string">'T'</span>, obj.st_o.T.v,<span class="keyword">...</span>
                <span class="string">'P'</span>, obj.st_o.p, obj.st_o.fluid);
            h_i = CoolProp.PropsSI(<span class="string">'H'</span>, <span class="string">'T'</span>, obj.st_i.T.v,<span class="keyword">...</span>
                <span class="string">'P'</span>, obj.st_i.p, obj.st_i.fluid);
            q_dr_1 = obj.st_i.q_m.v .* (h_o - h_i);
        <span class="keyword">end</span>
        <span class="keyword">function</span> q_dr_1 = q_dr_1_2(obj)
            <span class="comment">% Heat transferred from the air pipe to the air, W</span>
            T = (obj.st_i.T.v + obj.st_o.T.v)/2;
            p = (obj.st_i.p + obj.st_o.p)/2;
            density = CoolProp.PropsSI(<span class="string">'D'</span>, <span class="string">'T'</span>, T, <span class="string">'P'</span>, p, obj.st_i.fluid);
            v = 4 .* obj.st_i.q_m.v ./ (pi * obj.airPipe.d_i .^2 .* density);
            mu = CoolProp.PropsSI(<span class="string">'V'</span>, <span class="string">'T'</span>, T, <span class="string">'P'</span>, p, obj.st_i.fluid);
            Re = density * v * obj.airPipe.d_i / mu;
            Cp = CoolProp.PropsSI(<span class="string">'C'</span>, <span class="string">'T'</span>, T, <span class="string">'P'</span>, p, obj.st_i.fluid);
            k = CoolProp.PropsSI(<span class="string">'L'</span>, <span class="string">'T'</span>, T, <span class="string">'P'</span>, p, obj.st_i.fluid);
            Pr = Cp .* mu ./k;
            mu_cav = CoolProp.PropsSI(<span class="string">'V'</span>, <span class="string">'T'</span>, obj.T_p.v,<span class="keyword">...</span>
                <span class="string">'P'</span>, p, obj.st_i.fluid);
            Nu_prime = NuInPipe(Re, Pr, mu, mu_cav);

            c_r = 1 + 3.5 * obj.airPipe.d_i / (obj.d_cav - <span class="keyword">...</span>
                obj.airPipe.d_i - 2 * obj.airPipe.delta_a);
            Nu = c_r * Nu_prime;

            h = Nu * k / obj.airPipe.d_i;

            H_prime_c = obj.airPipe.d_i + 2 * obj.airPipe.delta_a;
            N = floor(obj.dep_cav ./ H_prime_c);
            H_c = obj.dep_cav ./ N;
            L_c = N .* sqrt((pi * obj.d_cav).^2 + H_c.^2);
            A_airPipe = pi * obj.airPipe.d_i .* L_c;

            DeltaT1 = obj.T_p.v - obj.st_i.T.v;
            DeltaT2 = obj.T_p.v - obj.st_o.T.v;
            DeltaT = LogMean(DeltaT1, DeltaT2);

            q_dr_1 = h .* A_airPipe .* DeltaT;
        <span class="keyword">end</span>
        <span class="keyword">function</span> q_ref = q_ref(obj)
            <span class="comment">% Reflected energy by the receiver, W</span>
            A_ap = pi * obj.d_ap .^ 2 / 4;

            alpha_eff = obj.airPipe.alpha ./ (obj.airPipe.alpha + <span class="keyword">...</span>
                (1 - obj.airPipe.alpha) .* (A_ap ./ obj.A_cav()));

            q_ref = (1 - alpha_eff) .* obj.q_in;
        <span class="keyword">end</span>
        <span class="keyword">function</span> q_cond_conv = q_cond_conv(obj)
            <span class="comment">% Convection loss from the insulating layer, W</span>
            mu = CoolProp.PropsSI(<span class="string">'V'</span>, <span class="string">'T'</span>, obj.amb.T.v, <span class="keyword">...</span>
                <span class="string">'P'</span>, obj.amb.p, obj.amb.fluid);
            density = CoolProp.PropsSI(<span class="string">'D'</span>, <span class="string">'T'</span>, obj.amb.T.v,<span class="keyword">...</span>
                <span class="string">'P'</span>, obj.amb.p, obj.amb.fluid);
            nu = mu ./ density;

            d_o = obj.insLayer.d_i + 2 * obj.insLayer.delta;

            Re = obj.amb.w .* d_o ./ nu;

            Cp = CoolProp.PropsSI(<span class="string">'C'</span>, <span class="string">'T'</span>, obj.amb.T.v, <span class="keyword">...</span>
                <span class="string">'P'</span>, obj.amb.p, obj.amb.fluid);
            k = CoolProp.PropsSI(<span class="string">'L'</span>, <span class="string">'T'</span>, obj.amb.T.v, <span class="keyword">...</span>
                <span class="string">'P'</span>, obj.amb.p, obj.amb.fluid);
            Pr = Cp .* mu ./ k;

            Nu = NuOfExternalCylinder(Re, Pr);

            h = Nu * k / d_o;
            A_ins = obj.A_ins;
            q_cond_conv = h .* A_ins .* (obj.T_ins.v - obj.amb.T.v);
        <span class="keyword">end</span>
        <span class="keyword">function</span> q_cond_rad = q_cond_rad(obj)
            <span class="comment">% Radiation loss from the insulating layer, W</span>
            q_cond_rad = obj.insLayer.epsilon .* obj.A_ins * <span class="keyword">...</span>
                Const.SIGMA .* (obj.T_ins.v.^4 - obj.amb.T.v .^ 4);
        <span class="keyword">end</span>
        <span class="keyword">function</span> q_cond_tot = q_cond_tot(obj)
            <span class="comment">% Heat loss from air pipe to the insulating layer, W</span>
            d_o = obj.insLayer.d_i + 2 * obj.insLayer.delta;
            q_cond_tot = (obj.T_p.v - obj.T_ins.v) ./ <span class="keyword">...</span>
                (log(d_o ./ obj.insLayer.d_i) ./ <span class="keyword">...</span>
                (2 * pi * obj.insLayer.lambda .* obj.dep_cav));
        <span class="keyword">end</span>
        <span class="keyword">function</span> q_conv_tot = q_conv_tot(obj)
            <span class="comment">% Total covection loss, W</span>
            T = (obj.T_p.v + obj.amb.T.v) / 2;   <span class="comment">% Film temperature is used</span>
            k = CoolProp.PropsSI(<span class="string">'L'</span>, <span class="string">'T'</span>, T, <span class="string">'P'</span>, obj.amb.p, obj.amb.fluid);

            d_bar_cav = obj.d_cav - 2 * obj.airPipe.d_i - 4 * <span class="keyword">...</span>
                obj.airPipe.delta_a;

            beta = CoolProp.PropsSI(<span class="string">'ISOBARIC_EXPANSION_COEFFICIENT'</span>, <span class="keyword">...</span>
                <span class="string">'T'</span>, T, <span class="string">'P'</span>, obj.amb.p, obj.amb.fluid);
            mu = CoolProp.PropsSI(<span class="string">'V'</span>, <span class="string">'T'</span>, T, <span class="string">'P'</span>, obj.amb.p, obj.amb.fluid);
            density = CoolProp.PropsSI(<span class="string">'D'</span>, <span class="string">'T'</span>, T, <span class="string">'P'</span>, <span class="keyword">...</span>
                obj.amb.p, obj.amb.fluid);
            nu = mu ./ density;
            Gr = Const.G * beta .* (obj.T_p.v - obj.amb.T.v) .* <span class="keyword">...</span>
                d_bar_cav .^ 3 ./ nu .^ 2;

            Nu = Nu_nat_conv(Gr, obj.T_p.v, obj.amb.T.v, <span class="keyword">...</span>
                obj.theta, obj.d_ap, d_bar_cav);
            h_nat = k .* Nu ./ d_bar_cav;

            h_for = 0.1967 * obj.amb.w .^ 1.849;

            q_conv_tot = (h_nat + h_for) .* obj.A_cav() .* <span class="keyword">...</span>
                (obj.T_p.v - obj.amb.T.v);
        <span class="keyword">end</span>
        <span class="keyword">function</span> q_rad_emit = q_rad_emit(obj)
            <span class="comment">% Emitted radiation loss, W</span>
            A_ap = pi * obj.d_ap .^ 2 / 4;
            alpha_eff = obj.airPipe.alpha ./ (obj.airPipe.alpha + <span class="keyword">...</span>
                (1 - obj.airPipe.alpha) .* (A_ap / obj.A_cav));
            epsilon_cav = alpha_eff;
            q_rad_emit = epsilon_cav .* A_ap * Const.SIGMA .* <span class="keyword">...</span>
                (obj.T_p.v .^4 - obj.amb.T.v .^ 4);
        <span class="keyword">end</span>
    <span class="keyword">end</span>
    <span class="keyword">methods</span>
        <span class="keyword">function</span> value = get.A_ins(obj)
            <span class="comment">% Get the insulating layer outside area, m^2</span>
            d_o = obj.insLayer.d_i + 2 * obj.insLayer.delta;
            value = pi * d_o .* (obj.dep_cav + obj.insLayer.delta);
        <span class="keyword">end</span>
        <span class="keyword">function</span> value = get.A_cav(obj)
            <span class="comment">% Get the cavity area, m^2</span>
            d_bar_cav = obj.d_cav - 2 * obj.airPipe.d_i <span class="keyword">...</span>
                - 4 * obj.airPipe.delta_a;
            value = pi * d_bar_cav .^ 2 / 4 + pi * d_bar_cav <span class="keyword">...</span>
                * obj.dep_cav + pi * (d_bar_cav .^ 2 - obj.d_ap .^ 2) / 4;
        <span class="keyword">end</span>
        <span class="keyword">function</span> value = get.q_use(obj)
            h_i = CoolProp.PropsSI(<span class="string">'H'</span>, <span class="string">'T'</span>, obj.st_i.T.v, <span class="string">'P'</span>, <span class="keyword">...</span>
                obj.st_i.p, obj.st_i.fluid);
            h_o = CoolProp.PropsSI(<span class="string">'H'</span>, <span class="string">'T'</span>, obj.st_o.T.v, <span class="string">'P'</span>, <span class="keyword">...</span>
                obj.st_o.p, obj.st_o.fluid);
            value = obj.st_i.q_m.v .* (h_o - h_i);
        <span class="keyword">end</span>
        <span class="keyword">function</span> value = get.q_tot(obj)
            value = obj.amb.I_r .* obj.A;
        <span class="keyword">end</span>
        <span class="keyword">function</span> value = get.eta(obj)
            value = obj.q_use ./ obj.q_tot;
        <span class="keyword">end</span>
    <span class="keyword">end</span>
<span class="keyword">end</span>
</pre><p class="footer"><br><a href="http://www.mathworks.com/products/matlab/">Published with MATLAB&reg; R2014b</a><br></p></div><!--
##### SOURCE BEGIN #####
classdef DishCollector
    %DishCollector is a kind of Collector who uses dish as the reflector
    %and uses volumetric receiver
    
    properties(Constant)
        A = 87.7;         % Aperture area of the collector, m^2
        gamma = 0.97;       % Intercept factor of the collector
        rho = 0.91;         % Reflectance of the collector
        shading = 0.95;     % Shading factor of the collector
        d_ap = 0.184;       % Aperture diameter of the dish receiver, m
        d_cav = 0.46;       % Diameter of the cavity of the dish receiver, m
        dep_cav = 0.23;     % Depth of the cavity of the dish receiver, m
        theta = Deg2Rad(45);% Dish aperture angle(0 is horizontal, 90 is vertically down)
    end
    properties
        amb;        % Ambient
        T_p;        % Temperature of the fluid pipe, K
        T_ins;      % Outside temperature of the insulating layer, K
        st_i;       % Inlet stream
        st_o;       % Outlet stream
        airPipe;    % Air pipe
        insLayer;   % Insulating layer
    end
    properties(Dependent)
        q_use;      % Energy used, transferred to the fluid     
        q_tot;      % Energy projected to the reflector, W
        eta;        % Thermal efficiency of the collector
    end
    properties(Dependent, Access = protected)
        A_ins;      % Insulating layer outside area, m^2
        A_cav;      % Cavity area, m^2
    end
    
    methods
        function obj = DishCollector
            obj.amb = Ambient;
            obj.T_ins = Temperature;
            obj.T_p = Temperature;
            obj.airPipe = AirPipe;
            obj.insLayer = InsLayer;
            obj.st_i = Stream;
            obj.st_o = Stream;
        end
        function q_in = q_in(obj)  
            % The accepted energy from the reflector, W
            q_in = obj.amb.I_r .* obj.A .* obj.gamma * obj.shading * obj.rho;
        end
        function q_dr_1 = q_dr_1_1(obj)    
            % Heat absorbed by the fluid, W
            h_o = CoolProp.PropsSI('H', 'T', obj.st_o.T.v,...
                'P', obj.st_o.p, obj.st_o.fluid);
            h_i = CoolProp.PropsSI('H', 'T', obj.st_i.T.v,...
                'P', obj.st_i.p, obj.st_i.fluid);
            q_dr_1 = obj.st_i.q_m.v .* (h_o - h_i);
        end
        function q_dr_1 = q_dr_1_2(obj) 
            % Heat transferred from the air pipe to the air, W
            T = (obj.st_i.T.v + obj.st_o.T.v)/2;
            p = (obj.st_i.p + obj.st_o.p)/2;
            density = CoolProp.PropsSI('D', 'T', T, 'P', p, obj.st_i.fluid);
            v = 4 .* obj.st_i.q_m.v ./ (pi * obj.airPipe.d_i .^2 .* density);
            mu = CoolProp.PropsSI('V', 'T', T, 'P', p, obj.st_i.fluid);
            Re = density * v * obj.airPipe.d_i / mu;
            Cp = CoolProp.PropsSI('C', 'T', T, 'P', p, obj.st_i.fluid);
            k = CoolProp.PropsSI('L', 'T', T, 'P', p, obj.st_i.fluid);
            Pr = Cp .* mu ./k;
            mu_cav = CoolProp.PropsSI('V', 'T', obj.T_p.v,...
                'P', p, obj.st_i.fluid);
            Nu_prime = NuInPipe(Re, Pr, mu, mu_cav);
            
            c_r = 1 + 3.5 * obj.airPipe.d_i / (obj.d_cav - ...
                obj.airPipe.d_i - 2 * obj.airPipe.delta_a);
            Nu = c_r * Nu_prime;
                        
            h = Nu * k / obj.airPipe.d_i;
            
            H_prime_c = obj.airPipe.d_i + 2 * obj.airPipe.delta_a;
            N = floor(obj.dep_cav ./ H_prime_c);
            H_c = obj.dep_cav ./ N;
            L_c = N .* sqrt((pi * obj.d_cav).^2 + H_c.^2);
            A_airPipe = pi * obj.airPipe.d_i .* L_c;
            
            DeltaT1 = obj.T_p.v - obj.st_i.T.v;
            DeltaT2 = obj.T_p.v - obj.st_o.T.v;
            DeltaT = LogMean(DeltaT1, DeltaT2);
            
            q_dr_1 = h .* A_airPipe .* DeltaT;
        end
        function q_ref = q_ref(obj)
            % Reflected energy by the receiver, W
            A_ap = pi * obj.d_ap .^ 2 / 4;
              
            alpha_eff = obj.airPipe.alpha ./ (obj.airPipe.alpha + ...
                (1 - obj.airPipe.alpha) .* (A_ap ./ obj.A_cav()));
            
            q_ref = (1 - alpha_eff) .* obj.q_in;
        end
        function q_cond_conv = q_cond_conv(obj)
            % Convection loss from the insulating layer, W
            mu = CoolProp.PropsSI('V', 'T', obj.amb.T.v, ...
                'P', obj.amb.p, obj.amb.fluid);
            density = CoolProp.PropsSI('D', 'T', obj.amb.T.v,...
                'P', obj.amb.p, obj.amb.fluid);
            nu = mu ./ density;
            
            d_o = obj.insLayer.d_i + 2 * obj.insLayer.delta;
            
            Re = obj.amb.w .* d_o ./ nu;
            
            Cp = CoolProp.PropsSI('C', 'T', obj.amb.T.v, ...
                'P', obj.amb.p, obj.amb.fluid);
            k = CoolProp.PropsSI('L', 'T', obj.amb.T.v, ...
                'P', obj.amb.p, obj.amb.fluid);
            Pr = Cp .* mu ./ k;
            
            Nu = NuOfExternalCylinder(Re, Pr);
            
            h = Nu * k / d_o;
            A_ins = obj.A_ins;
            q_cond_conv = h .* A_ins .* (obj.T_ins.v - obj.amb.T.v);
        end
        function q_cond_rad = q_cond_rad(obj)
            % Radiation loss from the insulating layer, W
            q_cond_rad = obj.insLayer.epsilon .* obj.A_ins * ...
                Const.SIGMA .* (obj.T_ins.v.^4 - obj.amb.T.v .^ 4);
        end
        function q_cond_tot = q_cond_tot(obj)
            % Heat loss from air pipe to the insulating layer, W
            d_o = obj.insLayer.d_i + 2 * obj.insLayer.delta;
            q_cond_tot = (obj.T_p.v - obj.T_ins.v) ./ ...
                (log(d_o ./ obj.insLayer.d_i) ./ ...
                (2 * pi * obj.insLayer.lambda .* obj.dep_cav));
        end
        function q_conv_tot = q_conv_tot(obj)
            % Total covection loss, W
            T = (obj.T_p.v + obj.amb.T.v) / 2;   % Film temperature is used
            k = CoolProp.PropsSI('L', 'T', T, 'P', obj.amb.p, obj.amb.fluid);
            
            d_bar_cav = obj.d_cav - 2 * obj.airPipe.d_i - 4 * ...
                obj.airPipe.delta_a;
            
            beta = CoolProp.PropsSI('ISOBARIC_EXPANSION_COEFFICIENT', ...
                'T', T, 'P', obj.amb.p, obj.amb.fluid);
            mu = CoolProp.PropsSI('V', 'T', T, 'P', obj.amb.p, obj.amb.fluid);
            density = CoolProp.PropsSI('D', 'T', T, 'P', ...
                obj.amb.p, obj.amb.fluid);
            nu = mu ./ density;
            Gr = Const.G * beta .* (obj.T_p.v - obj.amb.T.v) .* ...
                d_bar_cav .^ 3 ./ nu .^ 2;
            
            Nu = Nu_nat_conv(Gr, obj.T_p.v, obj.amb.T.v, ...
                obj.theta, obj.d_ap, d_bar_cav);
            h_nat = k .* Nu ./ d_bar_cav;
            
            h_for = 0.1967 * obj.amb.w .^ 1.849;

            q_conv_tot = (h_nat + h_for) .* obj.A_cav() .* ...
                (obj.T_p.v - obj.amb.T.v);
        end
        function q_rad_emit = q_rad_emit(obj)
            % Emitted radiation loss, W
            A_ap = pi * obj.d_ap .^ 2 / 4;
            alpha_eff = obj.airPipe.alpha ./ (obj.airPipe.alpha + ...
                (1 - obj.airPipe.alpha) .* (A_ap / obj.A_cav));
            epsilon_cav = alpha_eff;
            q_rad_emit = epsilon_cav .* A_ap * Const.SIGMA .* ...
                (obj.T_p.v .^4 - obj.amb.T.v .^ 4);
        end
    end
    methods
        function value = get.A_ins(obj)
            % Get the insulating layer outside area, m^2
            d_o = obj.insLayer.d_i + 2 * obj.insLayer.delta;
            value = pi * d_o .* (obj.dep_cav + obj.insLayer.delta);
        end
        function value = get.A_cav(obj)
            % Get the cavity area, m^2
            d_bar_cav = obj.d_cav - 2 * obj.airPipe.d_i ...
                - 4 * obj.airPipe.delta_a;
            value = pi * d_bar_cav .^ 2 / 4 + pi * d_bar_cav ...
                * obj.dep_cav + pi * (d_bar_cav .^ 2 - obj.d_ap .^ 2) / 4; 
        end
        function value = get.q_use(obj)
            h_i = CoolProp.PropsSI('H', 'T', obj.st_i.T.v, 'P', ...
                obj.st_i.p, obj.st_i.fluid);
            h_o = CoolProp.PropsSI('H', 'T', obj.st_o.T.v, 'P', ...
                obj.st_o.p, obj.st_o.fluid);
            value = obj.st_i.q_m.v .* (h_o - h_i);
        end
        function value = get.q_tot(obj)
            value = obj.amb.I_r .* obj.A;
        end
        function value = get.eta(obj)
            value = obj.q_use ./ obj.q_tot;
        end
    end
end
##### SOURCE END #####
--></body></html>